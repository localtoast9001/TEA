namespace TEAC;
uses TEAC, System;

type
    TypeCreationVisitor = class interface(ITypeDeclarationVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                log : ^MessageLog);
            function IsFailed() : boolean;
            procedure SetTarget(value : ^TypeDefinition);
            virtual procedure Visit(enumDecl : ^EnumDeclaration);
            virtual procedure Visit(classDecl : ^ClassDeclaration);
            virtual procedure Visit(methodTypeDecl : ^MethodTypeDeclaration);
            virtual procedure Visit(interfaceDecl : ^InterfaceDeclaration);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _log : ^MessageLog;
            _target : ^TypeDefinition;
            _failed : boolean;
    end;
    TypeResolverVisitor = class interface(ITypeReferenceVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                log : ^MessageLog);
            function GetResult() : ^TypeDefinition;
            virtual procedure Visit(namedTypeRef : ^NamedTypeReference);
            virtual procedure Visit(arrayTypeRef : ^ArrayTypeReference);
            virtual procedure Visit(pointerTypeRef : ^PointerTypeReference);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _log : ^MessageLog;
            _result : ^TypeDefinition;
    end;
    StatementVisitor = class interface(IStatementVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(statement : ^WhileStatement);
            virtual procedure Visit(statement : ^IfStatement);
            virtual procedure Visit(statement : ^DeleteStatement);
            virtual procedure Visit(statement : ^CallStatement);
            virtual procedure Visit(statement : ^AssignmentStatement);
            virtual procedure Visit(statement : ^BlockStatement);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
    end;
    ReferenceType = (Namespace, Type, TypeMember, ArgumentOrLocal);
    SyntaxAnalyzerExpressionVisitor = class interface(IExpressionVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(expr : ^TermExpression);
            virtual procedure Visit(expr : ^SimpleExpression);
            virtual procedure Visit(expr : ^RelationalExpression);
            virtual procedure Visit(expr : ^NotExpression);
            virtual procedure Visit(expr : ^NewExpression);
            virtual procedure Visit(expr : ^NegativeExpression);
            virtual procedure Visit(expr : ^LiteralDoubleExpression);
            virtual procedure Visit(expr : ^LiteralIntExpression);
            virtual procedure Visit(expr : ^LiteralStringExpression);
            virtual procedure Visit(expr : ^LiteralBooleanExpression);
            virtual procedure Visit(expr : ^LiteralNilExpression);
            virtual procedure Visit(expr : ^AddressExpression);
            virtual procedure Visit(expr : ^DereferenceExpression);
            virtual procedure Visit(expr : ^ArrayIndexReferenceExpression);
            virtual procedure Visit(expr : ^CallReferenceExpression);
            virtual procedure Visit(expr : ^MemberReferenceExpression);
            virtual procedure Visit(expr : ^InheritedReferenceExpression);
            virtual procedure Visit(expr : ^NamedReferenceExpression);
            procedure SetImposedType(value : ^TypeDefinition);
            function IsFailed() : boolean;
        var
            _imposedType : ^TypeDefinition;
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
            _failed : boolean;
    end;    
    ExpressionVisitor = class interface(IExpressionVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(expr : ^TermExpression);
            virtual procedure Visit(expr : ^SimpleExpression);
            virtual procedure Visit(expr : ^RelationalExpression);
            virtual procedure Visit(expr : ^NotExpression);
            virtual procedure Visit(expr : ^NewExpression);
            virtual procedure Visit(expr : ^NegativeExpression);
            virtual procedure Visit(expr : ^LiteralDoubleExpression);
            virtual procedure Visit(expr : ^LiteralIntExpression);
            virtual procedure Visit(expr : ^LiteralStringExpression);
            virtual procedure Visit(expr : ^LiteralBooleanExpression);
            virtual procedure Visit(expr : ^LiteralNilExpression);
            virtual procedure Visit(expr : ^AddressExpression);
            virtual procedure Visit(expr : ^DereferenceExpression);
            virtual procedure Visit(expr : ^ArrayIndexReferenceExpression);
            virtual procedure Visit(expr : ^CallReferenceExpression);
            virtual procedure Visit(expr : ^MemberReferenceExpression);
            virtual procedure Visit(expr : ^InheritedReferenceExpression);
            virtual procedure Visit(expr : ^NamedReferenceExpression);
            function GetCurrentReferenceType() : ReferenceType;
            function GetCurrentLocalOrArgIndex() : integer;
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
            _currentReferenceType : ReferenceType;
            _currentNamespaceRef : String;
            _currentTypeRef : ^TypeDefinition;
            _currentMemberRef : String;
            _currentLocalOrArgIndex : integer;
    end;

constructor TypeCreationVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _log := log;
    _target := nil;
    _failed := false;
end;

function TypeCreationVisitor.IsFailed() : boolean;
begin
    IsFailed := _failed;
end;

procedure TypeCreationVisitor.SetTarget(value : ^TypeDefinition);
begin
    _target := value;
end;

procedure TypeCreationVisitor.Visit(enumDecl : ^EnumDeclaration);
var
    constValue : integer = 0;
    valuesList : ^LinkedListOfString;
    valuesEnum : LinkedListEnumeratorOfString;
    enumValues : ^DictionaryOfStringToInteger;
    failed : boolean = false;
begin
    _target^.SetIsEnum(true);
    _target^.SetSize(4); 
    valuesList := enumDecl^.GetValues();
    valuesEnum := valuesList^.GetEnumerator();
    enumValues := _target^.GetEnumValues();
    { TODO: Validate values }
    while valuesEnum.MoveNext() do
    begin
        if not enumValues^.TryAssign(
            valuesEnum.GetCurrent(),
            constValue) then
            failed := true;
        constValue := constValue + 1;
    end;

    if failed then
        _failed := true;
end;

procedure TypeCreationVisitor.Visit(classDecl : ^ClassDeclaration);
var
    baseType : String;
    baseTypeDef : ^TypeDefinition = nil;
    methodList : ^LinkedListOfMethodDeclaration = nil;
    methodInfo : ^MethodInfo = nil;
    methodEnum : LinkedListEnumeratorOfMethodDeclaration;
begin
    _target^.SetIsClass(true);
    _target^.SetIsStaticClass(classDecl^.GetIsStatic());
    _target^.SetIsAbstractClass(classDecl^.GetIsAbstract());
    baseType.assign(classDecl^.GetBaseType());
    if baseType.Length() > 0 then
    begin
        if _context^.TryFindTypeByName(
            @baseType,
            @baseTypeDef) then
        begin
            _target^.SetBaseType(baseTypeDef);
        end
        else
        begin
            {TODO: log message }
            _failed := true;
        end;
    end;

    methodList := classDecl^.GetPublicMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            methodInfo^.SetIsPublic(true);
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end; 

    methodList := classDecl^.GetProtectedMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            methodInfo^.SetIsProtected(true);
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end; 

    methodList := classDecl^.GetPrivateMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end; 
end;

procedure TypeCreationVisitor.Visit(methodTypeDecl : ^MethodTypeDeclaration);
begin
    _target^.SetIsMethod(true);
end;

procedure TypeCreationVisitor.Visit(interfaceDecl : ^InterfaceDeclaration);
begin
    _target^.SetIsInterface(true);
end;

constructor TypeResolverVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _log := log;
    _result := nil;
end;

function TypeResolverVisitor.GetResult() : ^TypeDefinition;
begin
    GetResult := _result;
end;

procedure TypeResolverVisitor.Visit(namedTypeRef : ^NamedTypeReference);
begin
    if not _context^.TryFindTypeByName(
        namedTypeRef^.GetTypeName(),
        @_result) then
    begin
        {TODO: message type can't be found.}
    end;
end;

procedure TypeResolverVisitor.Visit(arrayTypeRef : ^ArrayTypeReference);
var
    elementResolver : TypeResolverVisitor;
    elementTypeRef : ^TypeReference = nil;
    elementType : ^TypeDefinition = nil;
begin
    elementResolver := TypeResolverVisitor(_context, _generator, _log);
    elementTypeRef := arrayTypeRef^.GetElementType();
    elementTypeRef^.Accept(@elementResolver);
    elementType := elementResolver.GetResult();
    if elementType <> nil then 
    begin
        {TODO: evaluate element count}
        _context^.TryGetArrayType(elementType, 0, @_result); 
    end;
end;

procedure TypeResolverVisitor.Visit(pointerTypeRef : ^PointerTypeReference);
var
    elementResolver : TypeResolverVisitor;
    elementTypeRef : ^TypeReference = nil;
    elementType : ^TypeDefinition = nil;
begin
    elementResolver := TypeResolverVisitor(_context, _generator, _log);
    elementTypeRef := pointerTypeRef^.GetElementType();
    elementTypeRef^.Accept(@elementResolver);
    elementType := elementResolver.GetResult();
    if elementType <> nil then 
    begin
        _context^.TryGetPointerType(elementType, @_result);
    end;
end;

constructor StatementVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
end;

procedure StatementVisitor.Visit(statement : ^WhileStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^IfStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^DeleteStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^CallStatement);
var
    exprVisitor : ExpressionVisitor; 
    callExpr : ^Expression;
begin
end;

procedure StatementVisitor.Visit(statement : ^AssignmentStatement);
var
    exprVisitor : ExpressionVisitor;
    valueSyntaxVisitor : SyntaxAnalyzerExpressionVisitor;
    storageVisitor : ExpressionVisitor;
    storageSyntaxVisitor : SyntaxAnalyzerExpressionVisitor;
    storage : ^ReferenceExpression;
    storageType : ^TypeDefinition;
    valueExpr : ^Expression;
    argOrLocalIndex : integer;
    assignStatement : ^OpStatement;
    methodStatements: ^LinkedListOfOpStatement;
begin
    valueSyntaxVisitor := SyntaxAnalyzerExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storageSyntaxVisitor := SyntaxAnalyzerExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    exprVisitor := ExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storageVisitor := ExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storage := statement^.GetStorage();
    valueExpr := statement^.GetValue();
    
    {Apply type constraints and check references before code gen.}
    storage^.Accept(@storageSyntaxVisitor);
    valueSyntaxVisitor.SetImposedType(storage^.GetResultType());
    valueExpr^.Accept(@valueSyntaxVisitor);

    {Revisit to generator the code.}
    valueExpr^.Accept(@exprVisitor);
    storage^.Accept(@storageVisitor);
    if storageVisitor.GetCurrentReferenceType() = ReferenceType.ArgumentOrLocal then
    begin
        argOrLocalIndex := storageVisitor.GetCurrentLocalOrArgIndex();
        storageType := storage^.GetResultType();
        assignStatement := new OpStatement();
        if argOrLocalIndex >= 0 then
            assignStatement^.AssignStoreArg(
                argOrLocalIndex, 
                storageType^.GetSize())
        else
            assignStatement^.AssignStoreLocal(
                -argOrLocalIndex - 1, 
                storageType^.GetSize());
        methodStatements := _methodImpl^.GetStatements();
        methodStatements^.Add(assignStatement);        
    end;
end;

procedure StatementVisitor.Visit(statement : ^BlockStatement);
var
    statementList : ^LinkedListOfStatement;
    statementEnum : LinkedListEnumeratorOfStatement;
    innerStatement : ^Statement;
begin
    statementList := statement^.GetStatements();
    statementEnum := statementList^.GetEnumerator();
    while statementEnum.MoveNext() do
    begin
        innerStatement := statementEnum.GetCurrent();
        innerStatement^.Accept(this);
    end;
end;

constructor SyntaxAnalyzerExpressionVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
    _imposedType := nil;
    _failed := false;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^TermExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^SimpleExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^RelationalExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^NotExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^NewExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^NegativeExpression);
var
    inner : ^Expression = expr^.GetInner();
begin
    inner^.Accept(this);
    expr^.SetResultType(inner^.GetResultType());
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralDoubleExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralIntExpression);
var
    imposedTypeFullName : ^String;
    intTypeName : String;
    i4Type : ^TypeDefinition;
    resultSet : boolean = false;
begin
    intTypeName.TryAssign('integer');
    if _imposedType <> nil then
    begin
        imposedTypeFullName := _imposedType^.GetFullName();
        if 
            (String.CompareOrdinal(imposedTypeFullName, 'integer') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'short') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'long') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'character') = 0) then
            begin
                expr^.SetResultType(_imposedType);
                resultSet := true;
            end;
    end;
    if not resultSet then
    begin
        if _context^.TryFindTypeByName(@intTypeName, @i4Type) then
            expr^.SetResultType(i4Type);
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralStringExpression);
var
    exprType : ^TypeDefinition;
    exprVal : ^String;
    charArrayTypeName : String;
    done : boolean = false;
begin
    exprVal := expr^.GetValue();
    if exprVal^.Length() = 1 then
    begin
        if _imposedType <> nil then
            if String.CompareOrdinal(
                _imposedType^.GetFullName(), 
                'character') = 0 then
            begin
                expr^.SetResultType(_imposedType);
                done := true;
            end;
    end;
    if not done then
    begin
        charArrayTypeName.TryAssign('#0character');
        if _context^.TryFindTypeByName(@charArrayTypeName, @exprType) then
            expr^.SetResultType(exprType)
        else
            _failed := true;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralBooleanExpression);
var
    exprType : ^TypeDefinition = nil;
    boolTypeName : String;
begin
    boolTypeName.TryAssign('boolean');
    if _context^.TryFindTypeByName(@boolTypeName, @exprType) then
        expr^.SetResultType(exprType)
    else
        _failed := true;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralNilExpression);
var
    exprType : ^TypeDefinition = nil;
    genPointerTypeName : String;
begin
    if _imposedType <> nil then
    begin
        if _imposedType^.GetIsPointer() then
            expr^.SetResultType(_imposedType)
        else if _imposedType^.GetIsArray() and (_imposedType^.GetArrayElementCount() = 0) then
            expr^.SetResultType(_imposedType)
        else
            _failed := true;
    end
    else
    begin
        genPointerTypeName.TryAssign('^');
        if _context^.TryFindTypeByName(@genPointerTypeName, @exprType) then
            expr^.SetResultType(exprType)
        else
            _failed := true;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^AddressExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^DereferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^ArrayIndexReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^CallReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^MemberReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^InheritedReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^NamedReferenceExpression);
var
    localOrArgIndex : integer;
    scope : ^Scope;
    varType : ^TypeDefinition;
begin
    scope := _methodImpl^.GetScope();
    if scope^.TryGetSymbolIndexByName(
        expr^.GetName(),
        @localOrArgIndex) then
    begin
        varType := scope^.GetSymbolTypeByIndex(localOrArgIndex);
        expr^.SetResultType(varType);
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.SetImposedType(
    value : ^TypeDefinition);
begin
    _imposedType := value;
end;

function SyntaxAnalyzerExpressionVisitor.IsFailed() : boolean;
begin
    IsFailed := _failed;
end;

constructor ExpressionVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
end;

procedure ExpressionVisitor.Visit(expr : ^TermExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^SimpleExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^RelationalExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NotExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NewExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NegativeExpression);
var
    methodStatements: ^LinkedListOfOpStatement = 
        _methodImpl^.GetStatements();
    inner : ^Expression = expr^.GetInner();
    statement : ^OpStatement;
    resultType : ^TypeDefinition = expr^.GetResultType();
begin
    inner^.Accept(this);
    statement := new OpStatement();
    if statement <> nil then
    begin
        statement^.AssignNeg(resultType^.GetSize());
        methodStatements^.Add(statement);
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralDoubleExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralIntExpression);
var
    methodStatements: ^LinkedListOfOpStatement;
    loadStatement : ^OpStatement;
    intType : ^TypeDefinition;
begin
    intType := expr^.GetResultType();
    loadStatement := new OpStatement();
    if loadStatement <> nil then
    begin
        loadStatement^.AssignLoadInt(
            expr^.GetValue(),
            intType^.GetSize());
        methodStatements := _methodImpl^.GetStatements();
        methodStatements^.Add(loadStatement);
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralStringExpression);
var
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
    resultType : ^TypeDefinition = expr^.GetResultType();
    loadIntStatement : ^OpStatement;
    loadStaticRefStatement : ^OpStatement;
    stringLabel : String;
    stringVal : String;
    stringChars : array of character;
    module : ^Module = _methodImpl^.GetModule();
begin
    stringVal.assign(expr^.GetValue());
    stringChars := stringVal.Characters();
    if String.CompareOrdinal(resultType^.GetFullName(), 'character') = 0 then
    begin
        loadIntStatement := new OpStatement();
        loadIntStatement^.AssignLoadInt(
            Convert.ToInteger(Convert.ToShort(stringChars[0])),
            resultType^.GetSize());
        statements^.Add(loadIntStatement);
    end
    else
    begin
        if module^.TryDefineStringLiteral(@stringVal, @stringLabel) then
        begin
            loadStaticRefStatement := new OpStatement();
            loadStaticRefStatement^.AssignLoadStaticRef(
                @stringLabel);
            statements^.Add(loadStaticRefStatement);
        end;
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralBooleanExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralNilExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^AddressExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^DereferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^ArrayIndexReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^CallReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^MemberReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^InheritedReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NamedReferenceExpression);
var
    localOrArgIndex : integer;
    scope : ^Scope;
begin
    scope := _methodImpl^.GetScope();
    if scope^.TryGetSymbolIndexByName(
        expr^.GetName(),
        @localOrArgIndex) then
    begin
        _currentReferenceType := ReferenceType.ArgumentOrLocal;
        _currentLocalOrArgIndex := localOrArgIndex; 
    end;
end;

function ExpressionVisitor.GetCurrentReferenceType() : ReferenceType;
begin
    GetCurrentReferenceType := _currentReferenceType;
end;

function ExpressionVisitor.GetCurrentLocalOrArgIndex() : integer;
begin
    GetCurrentLocalOrArgIndex := _currentLocalOrArgIndex;
end;

constructor CodeGenerator(log : ^MessageLog);
begin
    _log := log;
end;

function CodeGenerator.TryCreateTypes(
    context : ^CompilerContext;
    programUnit : ^ProgramUnit) : boolean;
var
    visitor : TypeCreationVisitor;
    typeList : ^LinkedListOfTypeDeclaration;
    typeEnum : LinkedListEnumeratorOfTypeDeclaration;
    typeDef : ^TypeDefinition = nil;
    typeDecl : ^TypeDeclaration = nil;
    usesList : ^LinkedListOfString;
    usesEnum : LinkedListEnumeratorOfString;
    failed : boolean = false;
begin
    visitor := TypeCreationVisitor(context, this, _log);
    TryCreateTypes := false;
    
    {Set namespace and uses in the context for type resolution}
    context^.SetNamespace(programUnit^.GetNamespace());
    usesList := programUnit^.GetUses();
    usesEnum := usesList^.GetEnumerator();
    while usesEnum.MoveNext() do
    begin
        if not context^.AddUses(usesEnum.GetCurrent()) then
            failed := true;
    end;

    typeList := programUnit^.GetTypes();
    typeEnum := typeList^.GetEnumerator();
    while typeEnum.MoveNext() do
    begin
        typeDecl := typeEnum.GetCurrent();
        if not context^.TryDeclareType(
            typeDecl^.GetName(),
            @typeDef) then
        begin
            {TODO: Message} 
            failed := true;
        end; 
    end;

    typeEnum := typeList^.GetEnumerator();
    while typeEnum.MoveNext() do
    begin
        typeDecl := typeEnum.GetCurrent();
        if context^.TryFindTypeByName(
            typeDecl^.GetName(),
            @typeDef) then
        begin
            typeDef^.SetIsPublic(typeDecl^.GetIsPublic());
            visitor.SetTarget(typeDef);
            typeDecl^.Accept(@visitor);
        end
        else
            failed := true;
    end;

    failed := failed or visitor.IsFailed();
    TryCreateTypes := not failed;
end;

function CodeGenerator.TryCreateMethod(
    context : ^CompilerContext;
    typeDef : ^TypeDefinition;
    method : ^MethodDeclaration;
    methodInfoRef : ^^MethodInfo) : boolean;
var
    methodInfo : ^MethodInfo = nil;
    methodReturnType : ^TypeReference = nil;
    resolvedMethodReturnType : ^TypeDefinition = nil;
    paramDef : ^TypeDefinition = nil;
    paramInfo : ^ParameterInfo = nil;
    methodParams : ^LinkedListOfParameterDeclaration = nil;
    currentParam : ^ParameterDeclaration = nil;
    paramNames : ^LinkedListOfString = nil;
    paramEnum : LinkedListEnumeratorOfParameterDeclaration;
    paramNameEnum : LinkedListEnumeratorOfString;
    success : boolean;
begin
    methodInfo := new MethodInfo(typeDef);
    success := methodInfo <> nil;
    if success then
    begin
        methodInfo^.SetName(method^.GetMethodName());
        methodInfo^.SetIsStatic(method^.GetIsStatic());
        methodInfo^.SetIsVirtual(
            method^.GetIsVirtual() or 
            method^.GetIsAbstract() or
            typeDef^.GetIsInterface());
        methodInfo^.SetIsAbstract(
            method^.GetIsAbstract() or
            typeDef^.GetIsInterface());
        methodReturnType := method^.GetReturnType();
        if methodReturnType <> nil then
        begin
            success := TryResolveTypeReference(
                context,
                methodReturnType,
                @resolvedMethodReturnType);
            if success then
            begin
                methodInfo^.SetReturnType(resolvedMethodReturnType);
            end;
        end;

        methodParams := method^.GetParameters();
        paramEnum := methodParams^.GetEnumerator();
        while success and paramEnum.MoveNext() do
        begin
            currentParam := paramEnum.GetCurrent();
            success := TryResolveTypeReference(
                context,
                currentParam^.GetParameterType(),
                @paramDef);
            if success then 
            begin
                paramNames := currentParam^.GetParameterNames();
                paramNameEnum := paramNames^.GetEnumerator();
                while success and paramNameEnum.MoveNext() do
                begin
                    paramInfo := new ParameterInfo(
                        paramNameEnum.GetCurrent(),
                        paramDef);
                    success := paramInfo <> nil;
                    if success then
                    begin
                        success := methodInfo^.AddParameter(paramInfo);
                        if not success then
                            delete paramInfo;
                    end;
                end;
            end;
        end;
    end;
    
    if not success and (methodInfo <> nil) then
    begin
        delete methodInfo;
        methodInfo := nil;
    end;

    methodInfoRef^ := methodInfo;
    TryCreateMethod := success;
end;

function CodeGenerator.CreateModule(
    context : ^CompilerContext;
    programUnit : ^ProgramUnit) : ^Module;
var
    module : ^Module = nil;
    methodDefs : ^LinkedListOfMethodDefinition;
    methodDef : ^MethodDefinition;
    methodDefEnum : LinkedListEnumeratorOfMethodDefinition; 
    failed : boolean = false;
begin
    module := new Module();
    if module <> nil then
    begin
        methodDefs := programUnit^.GetMethods();
        methodDefEnum := methodDefs^.GetEnumerator();
        while methodDefEnum.MoveNext() do 
        begin
            methodDef := methodDefEnum.GetCurrent();                
            if not TryImplementMethod(
                context,
                module,
                methodDef) then
                failed := true;
        end;
    end;

    if failed then
    begin
        delete module;
        module := nil;
    end;

    CreateModule := module;
end;

function CodeGenerator.TryImplementMethod(
    context : ^CompilerContext;
    module : ^Module;
    methodDef : ^MethodDefinition) : boolean; 
var
    methodInfo : ^MethodInfo = nil;
    methodImpl : ^MethodImpl = nil;
    parameters : LinkedListOfTypeDefinition;
    sourceParameters : ^LinkedListOfParameterDeclaration;
    paramEnum : LinkedListEnumeratorOfParameterDeclaration;
    paramNames : ^LinkedListOfString;
    paramNameEnum : LinkedListEnumeratorOfString;
    paramDecl : ^ParameterDeclaration;
    paramType : ^TypeDefinition;
    methodOwnerType : ^TypeDefinition = nil;
    statementVisitor : StatementVisitor;
    success : boolean = true;
begin
    sourceParameters := methodDef^.GetParameters();
    paramEnum := sourceParameters^.GetEnumerator();
    while success and paramEnum.MoveNext() do 
    begin
        paramDecl := paramEnum.GetCurrent();
        success := TryResolveTypeReference(
            context,
            paramDecl^.GetParameterType(),
            @paramType);
        if success then
        begin
            paramNames := paramDecl^.GetParameterNames();
            paramNameEnum := paramNames^.GetEnumerator();
            while success and paramNameEnum.MoveNext() do
            begin
                success := parameters.Add(paramType);
            end;
        end;
    end;

    if success then
        success := context^.TryFindMethodAndType(
            methodDef^.GetMethodNameReference(),
            @parameters,
            @methodOwnerType,
            @methodInfo);
    if not success then
    begin
        {TODO: Can't find method error}
    end;

    if success then
    begin
        methodImpl := new MethodImpl(module, methodInfo);
        success := methodImpl <> nil;
    end;

    if success then
        success := context^.BeginScope(methodInfo, methodImpl^.GetScope());

    if success then
        success := DefineLocalVariables(context, methodImpl, methodDef);

    statementVisitor := StatementVisitor(context, this, methodImpl, _log); 
    if success then
        statementVisitor.Visit(methodDef^.GetBody());

    if success then
        success := module^.AddMethodImpl(methodImpl);

    if not success and (methodImpl <> nil) then
    begin
        delete methodImpl;
    end;

    TryImplementMethod := success;
end;

function CodeGenerator.DefineLocalVariables(
    context : ^CompilerContext;
    methodImpl : ^MethodImpl; 
    methodDef : ^MethodDefinition) : boolean;
var
    localVars : ^VarBlock = nil;
    varDecl : ^VariableDeclaration = nil;
    varTypeRef : ^TypeReference = nil;
    varType : ^TypeDefinition = nil;
    scope : ^Scope = methodImpl^.GetScope();
    localVarList : ^LinkedListOfVariableDeclaration;
    localVarEnum : LinkedListEnumeratorOfVariableDeclaration;
    varNameList : ^LinkedListOfString;
    varNameEnum : LinkedListEnumeratorOfString;
    success : boolean = true;
begin
    localVars := methodDef^.GetLocalVariables();
    if localVars <> nil then
    begin
        localVarList := localVars^.GetVariables();
        localVarEnum := localVarList^.GetEnumerator();
        while success and localVarEnum.MoveNext() do
        begin
            varDecl := localVarEnum.GetCurrent();
            success := TryResolveTypeReference(
                context,
                varDecl^.GetVariableType(),
                @varType);
            if success then
            begin
                varNameList := varDecl^.GetVariableNames();
                varNameEnum := varNameList^.GetEnumerator();
                while success and varNameEnum.MoveNext() do
                begin
                    success := scope^.DefineLocalVariable(
                        varNameEnum.GetCurrent(),
                        varType);
                end;
            end;
        end;
    end;
    DefineLocalVariables := success;
end;

function CodeGenerator.TryResolveTypeReference(
    context : ^CompilerContext;
    typeRef : ^TypeReference;
    typeDefRef : ^^TypeDefinition) : boolean; 
var
    visitor : TypeResolverVisitor;
begin
    visitor := TypeResolverVisitor(
        context,
        this,
        _log);
    typeRef^.Accept(@visitor);
    typeDefRef^ := visitor.GetResult();
    TryResolveTypeReference := typeDefRef^ <> nil;
end;

