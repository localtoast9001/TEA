namespace TEAC;
uses TEAC, System;

type
    TypeCreationVisitor = class interface(ITypeDeclarationVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                log : ^MessageLog);
            function IsFailed() : boolean;
            procedure SetTarget(value : ^TypeDefinition);
            virtual procedure Visit(enumDecl : ^EnumDeclaration);
            virtual procedure Visit(classDecl : ^ClassDeclaration);
            virtual procedure Visit(methodTypeDecl : ^MethodTypeDeclaration);
            virtual procedure Visit(interfaceDecl : ^InterfaceDeclaration);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _log : ^MessageLog;
            _target : ^TypeDefinition;
            _failed : boolean;
    end;
    TypeResolverVisitor = class interface(ITypeReferenceVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                log : ^MessageLog);
            function GetResult() : ^TypeDefinition;
            virtual procedure Visit(namedTypeRef : ^NamedTypeReference);
            virtual procedure Visit(arrayTypeRef : ^ArrayTypeReference);
            virtual procedure Visit(pointerTypeRef : ^PointerTypeReference);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _log : ^MessageLog;
            _result : ^TypeDefinition;
    end;
    StatementVisitor = class interface(IStatementVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(statement : ^WhileStatement);
            virtual procedure Visit(statement : ^IfStatement);
            virtual procedure Visit(statement : ^DeleteStatement);
            virtual procedure Visit(statement : ^CallStatement);
            virtual procedure Visit(statement : ^AssignmentStatement);
            virtual procedure Visit(statement : ^BlockStatement);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
    end;
    SyntaxAnalyzerExpressionVisitor = class interface(IExpressionVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(expr : ^TermExpression);
            virtual procedure Visit(expr : ^SimpleExpression);
            virtual procedure Visit(expr : ^RelationalExpression);
            virtual procedure Visit(expr : ^NotExpression);
            virtual procedure Visit(expr : ^NewExpression);
            virtual procedure Visit(expr : ^NegativeExpression);
            virtual procedure Visit(expr : ^LiteralDoubleExpression);
            virtual procedure Visit(expr : ^LiteralIntExpression);
            virtual procedure Visit(expr : ^LiteralStringExpression);
            virtual procedure Visit(expr : ^LiteralBooleanExpression);
            virtual procedure Visit(expr : ^LiteralNilExpression);
            virtual procedure Visit(expr : ^AddressExpression);
            virtual procedure Visit(expr : ^DereferenceExpression);
            virtual procedure Visit(expr : ^ArrayIndexReferenceExpression);
            virtual procedure Visit(expr : ^CallReferenceExpression);
            virtual procedure Visit(expr : ^MemberReferenceExpression);
            virtual procedure Visit(expr : ^InheritedReferenceExpression);
            virtual procedure Visit(expr : ^NamedReferenceExpression);
            procedure SetImposedType(value : ^TypeDefinition);
            function IsFailed() : boolean;
        var
            _imposedType : ^TypeDefinition;
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
            _failed : boolean;
    end;    
    ExpressionVisitor = class interface(IExpressionVisitor)
        public
            constructor(
                context : ^CompilerContext;
                generator : ^CodeGenerator;
                methodImpl : ^MethodImpl;
                log : ^MessageLog);
            virtual procedure Visit(expr : ^TermExpression);
            virtual procedure Visit(expr : ^SimpleExpression);
            virtual procedure Visit(expr : ^RelationalExpression);
            virtual procedure Visit(expr : ^NotExpression);
            virtual procedure Visit(expr : ^NewExpression);
            virtual procedure Visit(expr : ^NegativeExpression);
            virtual procedure Visit(expr : ^LiteralDoubleExpression);
            virtual procedure Visit(expr : ^LiteralIntExpression);
            virtual procedure Visit(expr : ^LiteralStringExpression);
            virtual procedure Visit(expr : ^LiteralBooleanExpression);
            virtual procedure Visit(expr : ^LiteralNilExpression);
            virtual procedure Visit(expr : ^AddressExpression);
            virtual procedure Visit(expr : ^DereferenceExpression);
            virtual procedure Visit(expr : ^ArrayIndexReferenceExpression);
            virtual procedure Visit(expr : ^CallReferenceExpression);
            virtual procedure Visit(expr : ^MemberReferenceExpression);
            virtual procedure Visit(expr : ^InheritedReferenceExpression);
            virtual procedure Visit(expr : ^NamedReferenceExpression);
            function GetCurrentResolvedReference() : ^ResolvedReference;
            procedure GenerateLoadValue(expr : ^Expression);
        var
            _context : ^CompilerContext;
            _generator : ^CodeGenerator;
            _methodImpl : ^MethodImpl;
            _log : ^MessageLog;
            _currentResolvedReference : ^ResolvedReference;
    end;

constructor TypeCreationVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _log := log;
    _target := nil;
    _failed := false;
end;

function TypeCreationVisitor.IsFailed() : boolean;
begin
    IsFailed := _failed;
end;

procedure TypeCreationVisitor.SetTarget(value : ^TypeDefinition);
begin
    _target := value;
end;

procedure TypeCreationVisitor.Visit(enumDecl : ^EnumDeclaration);
var
    constValue : integer = 0;
    valuesList : ^LinkedListOfString;
    valuesEnum : LinkedListEnumeratorOfString;
    enumValues : ^DictionaryOfStringToInteger;
    failed : boolean = false;
begin
    _target^.SetIsEnum(true);
    _target^.SetSize(4); 
    valuesList := enumDecl^.GetValues();
    valuesEnum := valuesList^.GetEnumerator();
    enumValues := _target^.GetEnumValues();
    { TODO: Validate values }
    while valuesEnum.MoveNext() do
    begin
        if not enumValues^.TryAssign(
            valuesEnum.GetCurrent(),
            constValue) then
            failed := true;
        constValue := constValue + 1;
    end;

    if failed then
        _failed := true;
end;

procedure TypeCreationVisitor.Visit(classDecl : ^ClassDeclaration);
var
    baseType : String;
    baseTypeDef : ^TypeDefinition = nil;
    methodList : ^LinkedListOfMethodDeclaration = nil;
    methodInfo : ^MethodInfo = nil;
    methodEnum : LinkedListEnumeratorOfMethodDeclaration;
    fieldBlock : ^VarBlock = nil;
    fieldList : ^LinkedListOfVariableDeclaration = nil;
    fieldEnum : LinkedListEnumeratorOfVariableDeclaration;
    fieldInfo : ^FieldInfo = nil;
    sourceField : ^VariableDeclaration = nil;
    sourceFieldType : ^TypeDefinition;
    sourceFieldTypeRef : ^TypeReference;
    offset : integer = 0;
    typeResolver : TypeResolverVisitor;
    fieldNameList : ^LinkedListOfString;
    fieldNameEnum : LinkedListEnumeratorOfString;
begin
    typeResolver := TypeResolverVisitor(_context, _generator, _log);
    _target^.SetIsClass(true);
    _target^.SetIsStaticClass(classDecl^.GetIsStatic());
    _target^.SetIsAbstractClass(classDecl^.GetIsAbstract());
    baseType.assign(classDecl^.GetBaseType());
    if baseType.Length() > 0 then
    begin
        if _context^.TryFindTypeByName(
            @baseType,
            @baseTypeDef) then
        begin
            _target^.SetBaseType(baseTypeDef);
            offset := baseTypeDef^.GetSize();
        end
        else
        begin
            {TODO: log message }
            _failed := true;
        end;
    end;

    methodList := classDecl^.GetPublicMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            methodInfo^.SetIsPublic(true);
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end; 

    methodList := classDecl^.GetProtectedMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            methodInfo^.SetIsProtected(true);
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end; 

    methodList := classDecl^.GetPrivateMethods();
    methodEnum := methodList^.GetEnumerator();
    while methodEnum.MoveNext() do 
    begin
        if _generator^.TryCreateMethod(
            _context,
            _target,
            methodEnum.GetCurrent(),
            @methodInfo) then
        begin
            if not _target^.AddMethod(methodInfo) then
            begin
                delete methodInfo;
                methodInfo := nil;
                _failed := true;
            end;
        end 
        else
        begin
            _failed := true;
        end;
    end;

    fieldBlock := classDecl^.GetFields();
    if fieldBlock <> nil then
    begin
        fieldList := fieldBlock^.GetVariables();
        fieldEnum := fieldList^.GetEnumerator();
        while fieldEnum.MoveNext() do 
        begin
            sourceField := fieldEnum.GetCurrent();
            sourceFieldTypeRef := sourceField^.GetVariableType();
            sourceFieldTypeRef^.Accept(@typeResolver);
            sourceFieldType := typeResolver.GetResult();
            if sourceFieldType <> nil then
            begin
                fieldNameList := sourceField^.GetVariableNames();
                fieldNameEnum := fieldNameList^.GetEnumerator();
                while fieldNameEnum.MoveNext() do
                begin
                    fieldInfo := new FieldInfo();
                    if fieldInfo <> nil then
                    begin
                        fieldInfo^.SetName(fieldNameEnum.GetCurrent());
                        fieldInfo^.SetType(sourceFieldType);
                        fieldInfo^.SetOffset(offset);
                        offset := offset + sourceFieldType^.GetSize();
                        if not _target^.AddField(fieldInfo) then
                        begin
                            _failed := true;
                            delete fieldInfo;
                        end;
                    end
                    else
                        _failed := true;
                end;
            end
            else
                _failed := true;
        end;
    end;

    _target^.SetSize(offset);
end;

procedure TypeCreationVisitor.Visit(methodTypeDecl : ^MethodTypeDeclaration);
begin
    _target^.SetIsMethod(true);
end;

procedure TypeCreationVisitor.Visit(interfaceDecl : ^InterfaceDeclaration);
begin
    _target^.SetIsInterface(true);
end;

constructor TypeResolverVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _log := log;
    _result := nil;
end;

function TypeResolverVisitor.GetResult() : ^TypeDefinition;
begin
    GetResult := _result;
end;

procedure TypeResolverVisitor.Visit(namedTypeRef : ^NamedTypeReference);
begin
    if not _context^.TryFindTypeByName(
        namedTypeRef^.GetTypeName(),
        @_result) then
    begin
        {TODO: message type can't be found.}
    end;
end;

procedure TypeResolverVisitor.Visit(arrayTypeRef : ^ArrayTypeReference);
var
    elementResolver : TypeResolverVisitor;
    elementTypeRef : ^TypeReference = nil;
    elementType : ^TypeDefinition = nil;
begin
    elementResolver := TypeResolverVisitor(_context, _generator, _log);
    elementTypeRef := arrayTypeRef^.GetElementType();
    elementTypeRef^.Accept(@elementResolver);
    elementType := elementResolver.GetResult();
    if elementType <> nil then 
    begin
        {TODO: evaluate element count}
        _context^.TryGetArrayType(elementType, 0, @_result); 
    end;
end;

procedure TypeResolverVisitor.Visit(pointerTypeRef : ^PointerTypeReference);
var
    elementResolver : TypeResolverVisitor;
    elementTypeRef : ^TypeReference = nil;
    elementType : ^TypeDefinition = nil;
begin
    elementResolver := TypeResolverVisitor(_context, _generator, _log);
    elementTypeRef := pointerTypeRef^.GetElementType();
    elementTypeRef^.Accept(@elementResolver);
    elementType := elementResolver.GetResult();
    if elementType <> nil then 
    begin
        _context^.TryGetPointerType(elementType, @_result);
    end;
end;

constructor StatementVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
end;

procedure StatementVisitor.Visit(statement : ^WhileStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^IfStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^DeleteStatement);
begin
end;

procedure StatementVisitor.Visit(statement : ^CallStatement);
var
    exprVisitor : ExpressionVisitor; 
    callExpr : ^Expression;
begin
end;

procedure StatementVisitor.Visit(statement : ^AssignmentStatement);
var
    exprVisitor : ExpressionVisitor;
    valueSyntaxVisitor : SyntaxAnalyzerExpressionVisitor;
    storageVisitor : ExpressionVisitor;
    storageSyntaxVisitor : SyntaxAnalyzerExpressionVisitor;
    storage : ^ReferenceExpression;
    storageType : ^TypeDefinition;
    valueExpr : ^Expression;
    storageResolvedRef : ^ResolvedReference;
    argOrLocalIndex : integer;
    assignStatement : ^OpStatement;
    methodStatements: ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
    fieldRef : ^FieldInfo;
begin
    valueSyntaxVisitor := SyntaxAnalyzerExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storageSyntaxVisitor := SyntaxAnalyzerExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    exprVisitor := ExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storageVisitor := ExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    storage := statement^.GetStorage();
    valueExpr := statement^.GetValue();
    
    {Apply type constraints and check references before code gen.}
    storage^.Accept(@storageSyntaxVisitor);
    valueSyntaxVisitor.SetImposedType(storage^.GetResultType());
    valueExpr^.Accept(@valueSyntaxVisitor);

    {Revisit to generator the code.}
    valueExpr^.Accept(@exprVisitor);
    exprVisitor.GenerateLoadValue(valueExpr);
    storage^.Accept(@storageVisitor);
    storageResolvedRef := storageVisitor.GetCurrentResolvedReference();
    storageType := storage^.GetResultType();
    if storageResolvedRef^.GetReferenceType() = ReferenceType.ArgumentOrLocal then
    begin
        argOrLocalIndex := storageResolvedRef^.GetLocalOrArgIndex();
        assignStatement := new OpStatement();
        if argOrLocalIndex >= 0 then
            assignStatement^.AssignStoreArg(
                argOrLocalIndex, 
                storageType^.GetSize())
        else
            assignStatement^.AssignStoreLocal(
                -argOrLocalIndex - 1, 
                storageType^.GetSize());
        methodStatements^.Add(assignStatement);        
    end
    else if storageResolvedRef^.GetReferenceType() = ReferenceType.TypeMember then
    begin
        fieldRef := storageResolvedRef^.GetFieldInfo();
        if fieldRef <> nil then
        begin
            assignStatement := new OpStatement();
            if assignStatement <> nil then
            begin
                assignStatement^.AssignStoreField(fieldRef^.GetOffset(), storageType^.GetSize());
                methodStatements^.Add(assignStatement);
            end;
        end;
    end
    else if storageResolvedRef^.GetReferenceType() = ReferenceType.Pointer then
    begin
        assignStatement := new OpStatement();
        if assignStatement <> nil then
        begin
            assignStatement^.AssignStoreIndirect(storageType^.GetSize());
            methodStatements^.Add(assignStatement);
        end;
    end;
end;

procedure StatementVisitor.Visit(statement : ^BlockStatement);
var
    statementList : ^LinkedListOfStatement;
    statementEnum : LinkedListEnumeratorOfStatement;
    innerStatement : ^Statement;
begin
    statementList := statement^.GetStatements();
    statementEnum := statementList^.GetEnumerator();
    while statementEnum.MoveNext() do
    begin
        innerStatement := statementEnum.GetCurrent();
        innerStatement^.Accept(this);
    end;
end;

constructor SyntaxAnalyzerExpressionVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
    _imposedType := nil;
    _failed := false;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^TermExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^SimpleExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^RelationalExpression);
var
    boolType : ^TypeDefinition = nil;
    boolTypeName : String;
    left : ^Expression = expr^.GetLeft();
    right : ^Expression = expr^.GetRight();
    leftVisit : SyntaxAnalyzerExpressionVisitor;
    rightVisit : SyntaxAnalyzerExpressionVisitor;
begin
    leftVisit := SyntaxAnalyzerExpressionVisitor(_context, _generator, _methodImpl, _log);
    rightVisit := SyntaxAnalyzerExpressionVisitor(_context, _generator, _methodImpl, _log);
    left^.Accept(@leftVisit);
    right^.Accept(@rightVisit);
    boolTypeName.TryAssign('boolean');
    if _context^.TryFindTypeByName(@boolTypeName, @boolType) then
        expr^.SetResultType(boolType); 
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^NotExpression);
var
    inner : ^Expression = expr^.GetInner();
begin
    inner^.Accept(this);
    expr^.SetResultType(inner^.GetResultType());
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(expr : ^NewExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^NegativeExpression);
var
    inner : ^Expression = expr^.GetInner();
begin
    inner^.Accept(this);
    expr^.SetResultType(inner^.GetResultType());
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralDoubleExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralIntExpression);
var
    imposedTypeFullName : ^String;
    intTypeName : String;
    i4Type : ^TypeDefinition;
    resultSet : boolean = false;
begin
    intTypeName.TryAssign('integer');
    if _imposedType <> nil then
    begin
        imposedTypeFullName := _imposedType^.GetFullName();
        if 
            (String.CompareOrdinal(imposedTypeFullName, 'integer') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'short') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'long') = 0) or
            (String.CompareOrdinal(imposedTypeFullName, 'character') = 0) then
            begin
                expr^.SetResultType(_imposedType);
                resultSet := true;
            end;
    end;
    if not resultSet then
    begin
        if _context^.TryFindTypeByName(@intTypeName, @i4Type) then
            expr^.SetResultType(i4Type);
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralStringExpression);
var
    exprType : ^TypeDefinition;
    exprVal : ^String;
    charArrayTypeName : String;
    done : boolean = false;
begin
    exprVal := expr^.GetValue();
    if exprVal^.Length() = 1 then
    begin
        if _imposedType <> nil then
            if String.CompareOrdinal(
                _imposedType^.GetFullName(), 
                'character') = 0 then
            begin
                expr^.SetResultType(_imposedType);
                done := true;
            end;
    end;
    if not done then
    begin
        charArrayTypeName.TryAssign('#0character');
        if _context^.TryFindTypeByName(@charArrayTypeName, @exprType) then
            expr^.SetResultType(exprType)
        else
            _failed := true;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralBooleanExpression);
var
    exprType : ^TypeDefinition = nil;
    boolTypeName : String;
begin
    boolTypeName.TryAssign('boolean');
    if _context^.TryFindTypeByName(@boolTypeName, @exprType) then
        expr^.SetResultType(exprType)
    else
        _failed := true;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^LiteralNilExpression);
var
    exprType : ^TypeDefinition = nil;
    genPointerTypeName : String;
begin
    if _imposedType <> nil then
    begin
        if _imposedType^.GetIsPointer() then
            expr^.SetResultType(_imposedType)
        else if _imposedType^.GetIsArray() and (_imposedType^.GetArrayElementCount() = 0) then
            expr^.SetResultType(_imposedType)
        else
            _failed := true;
    end
    else
    begin
        genPointerTypeName.TryAssign('^');
        if _context^.TryFindTypeByName(@genPointerTypeName, @exprType) then
            expr^.SetResultType(exprType)
        else
            _failed := true;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^AddressExpression);
var
    innerExpr : ^ReferenceExpression = expr^.GetInner();
    addrType : ^TypeDefinition = nil;
begin
    innerExpr^.Accept(this);
    if not _failed then
    begin
        if not _context^.TryGetPointerType(innerExpr^.GetResultType(), @addrType) then
            _failed := true
        else
        begin
            expr^.SetResultType(addrType);
        end;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^DereferenceExpression);
var
    innerExpr : ^ReferenceExpression = expr^.GetInner();
    ptrType, elemType : ^TypeDefinition = nil;
begin
    innerExpr^.Accept(this);
    if not _failed then
    begin
        ptrType := innerExpr^.GetResultType();
        if ptrType^.GetIsPointer() then
        begin
            elemType := ptrType^.GetInnerType();
            expr^.SetResultType(elemType);
            expr^.SetResolvedReference(new ResolvedReference(ReferenceType.Pointer));
        end
        else
        begin
            {TODO: Error message. A non-pointer type cannot be dereferenced.}
            _failed := true;
        end;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^ArrayIndexReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^CallReferenceExpression);
var
    innerVisitor : SyntaxAnalyzerExpressionVisitor;
    innerRef : ^ReferenceExpression = expr^.GetInner();
    args : ^LinkedListOfExpression = expr^.GetArguments();
    argEnum : LinkedListEnumeratorOfExpression;
    meth : ^MethodInfo;
    arg : ^Expression;
begin
    {TODO: Handle overload}
    {TODO: Handle imposed types for args}
    innerVisitor := SyntaxAnalyzerExpressionVisitor(
        _context,
        _generator,
        _methodImpl,
        _log);
    innerRef^.Accept(@innerVisitor);
    argEnum := args^.GetEnumerator();
    while argEnum.MoveNext() do 
    begin
        innerVisitor := SyntaxAnalyzerExpressionVisitor(
            _context,
            _generator,
            _methodImpl,
            _log);
        arg := argEnum.GetCurrent();
        arg^.Accept(@innerVisitor);
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^MemberReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^InheritedReferenceExpression);
begin
end;

procedure SyntaxAnalyzerExpressionVisitor.Visit(
    expr : ^NamedReferenceExpression);
var
    localOrArgIndex : integer;
    scope : ^Scope;
    varType : ^TypeDefinition;
    currentMethod, testMethod, matchMethod : ^MethodInfo;
    currentMethodType : ^TypeDefinition;
    resolvedRef : ^ResolvedReference;
    methodList : ^LinkedListOfMethodInfo;
    methodEnum : LinkedListEnumeratorOfMethodInfo;
    fieldList : ^LinkedListOfFieldInfo;
    fieldEnum : LinkedListEnumeratorOfFieldInfo;
    testField, matchField : ^FieldInfo;
    found : boolean = false;
begin
    scope := _methodImpl^.GetScope();
    currentMethod := _methodImpl^.GetMethodInfo();
    currentMethodType := currentMethod^.GetOwnerType();
    if scope^.TryGetSymbolIndexByName(
        expr^.GetName(),
        @localOrArgIndex) then
    begin
        varType := scope^.GetSymbolTypeByIndex(localOrArgIndex);
        expr^.SetResultType(varType);
        resolvedRef := new ResolvedReference(ReferenceType.ArgumentOrLocal);
        resolvedRef^.SetLocalOrArgIndex(localOrArgIndex);
        expr^.SetResolvedReference(resolvedRef);
    end
    else
    begin
        {TODO: Method Protection filtering.}
        {TODO: Overloads.}
        {TODO: Reference Base class.}
        methodList := currentMethodType^.GetMethods();
        methodEnum := methodList^.GetEnumerator();
        while not found and methodEnum.MoveNext() do
        begin
            testMethod := methodEnum.GetCurrent();
            if String.CompareOrdinal(testMethod^.GetName(), expr^.GetName()) = 0 then
            begin
                found := true;
                matchMethod := testMethod;
            end;
        end;

        if found then
        begin
            resolvedRef := new ResolvedReference(ReferenceType.TypeMember);
            resolvedRef^.SetTypeMember(
                currentMethodType,
                matchMethod^.GetName(),
                matchMethod,
                nil);
            expr^.SetResolvedReference(resolvedRef);
            expr^.SetResultType(matchMethod^.GetReturnType());
        end;
    
        {Search for field.}    
        if not found then
        begin
            if not currentMethod^.GetIsStatic() then
            begin
                fieldList := currentMethodType^.GetFields();
                fieldEnum := fieldList^.GetEnumerator();
                while not found and fieldEnum.MoveNext() do
                begin
                    testField := fieldEnum.GetCurrent();
                    if String.CompareOrdinal(testField^.GetName(), expr^.GetName()) = 0 then
                    begin
                        found := true;
                        matchField := testField;
                    end;
                end;

                if found then
                begin
                    resolvedRef := new ResolvedReference(ReferenceType.TypeMember);
                    resolvedRef^.SetTypeMember(
                        currentMethodType,
                        matchField^.GetName(),
                        nil,
                        matchField);
                    expr^.SetResolvedReference(resolvedRef);
                    expr^.SetResultType(matchField^.GetType());
                end;
            end;
        end;
    end;
end;

procedure SyntaxAnalyzerExpressionVisitor.SetImposedType(
    value : ^TypeDefinition);
begin
    _imposedType := value;
end;

function SyntaxAnalyzerExpressionVisitor.IsFailed() : boolean;
begin
    IsFailed := _failed;
end;

constructor ExpressionVisitor(
    context : ^CompilerContext;
    generator : ^CodeGenerator;
    methodImpl : ^MethodImpl;
    log : ^MessageLog);
begin
    _context := context;
    _generator := generator;
    _methodImpl := methodImpl;
    _log := log;
    _currentResolvedReference := nil;
end;

procedure ExpressionVisitor.Visit(expr : ^TermExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^SimpleExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^RelationalExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NotExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NewExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NegativeExpression);
var
    methodStatements: ^LinkedListOfOpStatement = 
        _methodImpl^.GetStatements();
    inner : ^Expression = expr^.GetInner();
    statement : ^OpStatement;
    resultType : ^TypeDefinition = expr^.GetResultType();
begin
    inner^.Accept(this);
    statement := new OpStatement();
    if statement <> nil then
    begin
        statement^.AssignNeg(resultType^.GetSize());
        methodStatements^.Add(statement);
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralDoubleExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralIntExpression);
var
    methodStatements: ^LinkedListOfOpStatement;
    loadStatement : ^OpStatement;
    intType : ^TypeDefinition;
begin
    intType := expr^.GetResultType();
    loadStatement := new OpStatement();
    if loadStatement <> nil then
    begin
        loadStatement^.AssignLoadInt(
            expr^.GetValue(),
            intType^.GetSize());
        methodStatements := _methodImpl^.GetStatements();
        methodStatements^.Add(loadStatement);
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralStringExpression);
var
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
    resultType : ^TypeDefinition = expr^.GetResultType();
    loadIntStatement : ^OpStatement;
    loadStaticRefStatement : ^OpStatement;
    stringLabel : String;
    stringVal : String;
    stringChars : array of character;
    module : ^Module = _methodImpl^.GetModule();
begin
    stringVal.assign(expr^.GetValue());
    stringChars := stringVal.Characters();
    if String.CompareOrdinal(resultType^.GetFullName(), 'character') = 0 then
    begin
        loadIntStatement := new OpStatement();
        loadIntStatement^.AssignLoadInt(
            Convert.ToInteger(Convert.ToShort(stringChars[0])),
            resultType^.GetSize());
        statements^.Add(loadIntStatement);
    end
    else
    begin
        if module^.TryDefineStringLiteral(@stringVal, @stringLabel) then
        begin
            loadStaticRefStatement := new OpStatement();
            loadStaticRefStatement^.AssignLoadStaticRef(
                @stringLabel);
            statements^.Add(loadStaticRefStatement);
        end;
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralBooleanExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^LiteralNilExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^AddressExpression);
var
    exprType : ^TypeDefinition = expr^.GetResultType();
    innerExpr : ^ReferenceExpression = expr^.GetInner();
    innerRef : ^ResolvedReference = nil;
    fieldRef : ^FieldInfo = nil;
    argOrLocalIndex : integer = 0;
    innerVisitor : ExpressionVisitor;
    loadStatement : ^OpStatement = nil;
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
begin
    innerVisitor := ExpressionVisitor(_context, _generator, _methodImpl, _log);
    innerExpr^.Accept(@innerVisitor);
    innerRef := innerExpr^.GetResolvedReference();
    _currentResolvedReference := nil;
    if innerRef^.GetReferenceType() = ReferenceType.ArgumentOrLocal then
    begin
        loadStatement := new OpStatement();
        argOrLocalIndex := innerRef^.GetLocalOrArgIndex();
        if argOrLocalIndex < 0 then
            loadStatement^.AssignLoadLocalRef(
                -argOrLocalIndex - 1, 
                exprType^.GetSize())
        else
            loadStatement^.AssignLoadArgRef(
                argOrLocalIndex, 
                exprType^.GetSize());
        statements^.Add(loadStatement);
    end
    else if innerRef^.GetReferenceType() = ReferenceType.TypeMember then
    begin
        fieldRef := innerRef^.GetFieldInfo();
        if fieldRef <> nil then
        begin
            loadStatement := new OpStatement();
            loadStatement^.AssignLoadFieldRef(
                fieldRef^.GetOffset(),
                exprType^.GetSize());
            statements^.Add(loadStatement);
        end;
    end
    else
    begin
        {TODO: Error message.}
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^DereferenceExpression);
var
    innerExpr : ^ReferenceExpression = expr^.GetInner();
    innerRef : ^ResolvedReference = nil;
    innerVisitor : ExpressionVisitor;
begin
    innerVisitor := ExpressionVisitor(_context, _generator, _methodImpl, _log);
    innerExpr^.Accept(@innerVisitor);
    innerVisitor.GenerateLoadValue(innerExpr);
    _currentResolvedReference := expr^.GetResolvedReference(); 
end;

procedure ExpressionVisitor.Visit(expr : ^ArrayIndexReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^CallReferenceExpression);
var
    args : ^LinkedListOfExpression;
    argEnum : LinkedListReverseEnumeratorOfExpression; 
    argVisitor : ExpressionVisitor;
    innerVisitor : ExpressionVisitor;
    arg : ^Expression;
    inner : ^ReferenceExpression = expr^.GetInner();
    innerRef : ^ResolvedReference;
    meth : ^MethodInfo;
    methMangledName : String;
    callStatement : ^OpStatement;
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
begin
    args := expr^.GetArguments();
    argEnum := args^.GetReverseEnumerator();
    while argEnum.MoveNext() do
    begin
        argVisitor := ExpressionVisitor(_context, _generator, _methodImpl, _log);
        arg := argEnum.GetCurrent();
        arg^.Accept(@argVisitor);
        argVisitor.GenerateLoadValue(arg);
    end;

    innerVisitor := ExpressionVisitor(_context, _generator, _methodImpl, _log);
    inner^.Accept(@innerVisitor);
    innerRef := innerVisitor.GetCurrentResolvedReference();
    if innerRef^.GetReferenceType() = ReferenceType.TypeMember then
    begin
        meth := innerRef^.GetMethodInfo();
        if meth^.GetMangledName(@methMangledName) then
        begin
            callStatement := new OpStatement();
            callStatement^.AssignCall(@methMangledName);
            statements^.Add(callStatement);
        end;
    end;
end;

procedure ExpressionVisitor.Visit(expr : ^MemberReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^InheritedReferenceExpression);
begin
end;

procedure ExpressionVisitor.Visit(expr : ^NamedReferenceExpression);
var
    fieldRef : ^FieldInfo;    
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
    loadThisStatement : ^OpStatement;
begin
    _currentResolvedReference := expr^.GetResolvedReference();
    if _currentResolvedReference^.GetReferenceType() = ReferenceType.TypeMember then
    begin
        fieldRef := _currentResolvedReference^.GetFieldInfo();
        if fieldRef <> nil then
        begin
            loadThisStatement := new OpStatement();
            if loadThisStatement <> nil then
            begin
                loadThisStatement^.AssignLoadArg(0, 4);
                statements^.Add(loadThisStatement);
            end;
        end;
    end;
end;

function ExpressionVisitor.GetCurrentResolvedReference() : ^ResolvedReference;
begin
    GetCurrentResolvedReference := _currentResolvedReference;
end;

procedure ExpressionVisitor.GenerateLoadValue(expr : ^Expression);
var
    exprType : ^TypeDefinition = expr^.GetResultType();
    loadStatement : ^OpStatement;
    argOrLocalIndex : integer;
    fieldRef : ^FieldInfo;
    statements : ^LinkedListOfOpStatement = _methodImpl^.GetStatements();
begin
    if _currentResolvedReference <> nil then
    begin
        loadStatement := new OpStatement();
        if loadStatement <> nil then
        begin
            if _currentResolvedReference^.GetReferenceType() = ReferenceType.ArgumentOrLocal then
            begin
                argOrLocalIndex := _currentResolvedReference^.GetLocalOrArgIndex();
                if argOrLocalIndex < 0 then
                    loadStatement^.AssignLoadLocal(
                        -argOrLocalIndex - 1, 
                        exprType^.GetSize())
                else
                    loadStatement^.AssignLoadArg(
                        argOrLocalIndex, 
                        exprType^.GetSize());

                statements^.Add(loadStatement);
            end
            else if _currentResolvedReference^.GetReferenceType() = ReferenceType.TypeMember then
            begin
                fieldRef := _currentResolvedReference^.GetFieldInfo();
                if fieldRef <> nil then
                begin
                    loadStatement^.AssignLoadField(
                        fieldRef^.GetOffset(),
                        exprType^.GetSize());

                    statements^.Add(loadStatement);
                end;
            end
            else if _currentResolvedReference^.GetReferenceType() = ReferenceType.Pointer then
            begin
                loadStatement^.AssignLoadIndirect(
                    exprType^.GetSize());
                statements^.Add(loadStatement);
            end; 
        end;
    end;
end;

constructor CodeGenerator(log : ^MessageLog);
begin
    _log := log;
end;

function CodeGenerator.TryCreateTypes(
    context : ^CompilerContext;
    programUnit : ^ProgramUnit) : boolean;
var
    visitor : TypeCreationVisitor;
    typeList : ^LinkedListOfTypeDeclaration;
    typeEnum : LinkedListEnumeratorOfTypeDeclaration;
    typeDef : ^TypeDefinition = nil;
    typeDecl : ^TypeDeclaration = nil;
    usesList : ^LinkedListOfString;
    usesEnum : LinkedListEnumeratorOfString;
    failed : boolean = false;
begin
    visitor := TypeCreationVisitor(context, this, _log);
    TryCreateTypes := false;
    
    {Set namespace and uses in the context for type resolution}
    context^.SetNamespace(programUnit^.GetNamespace());
    usesList := programUnit^.GetUses();
    usesEnum := usesList^.GetEnumerator();
    while usesEnum.MoveNext() do
    begin
        if not context^.AddUses(usesEnum.GetCurrent()) then
            failed := true;
    end;

    typeList := programUnit^.GetTypes();
    typeEnum := typeList^.GetEnumerator();
    while typeEnum.MoveNext() do
    begin
        typeDecl := typeEnum.GetCurrent();
        if not context^.TryDeclareType(
            typeDecl^.GetName(),
            @typeDef) then
        begin
            {TODO: Message} 
            failed := true;
        end; 
    end;

    typeEnum := typeList^.GetEnumerator();
    while typeEnum.MoveNext() do
    begin
        typeDecl := typeEnum.GetCurrent();
        if context^.TryFindTypeByName(
            typeDecl^.GetName(),
            @typeDef) then
        begin
            typeDef^.SetIsPublic(typeDecl^.GetIsPublic());
            visitor.SetTarget(typeDef);
            typeDecl^.Accept(@visitor);
        end
        else
            failed := true;
    end;

    failed := failed or visitor.IsFailed();
    TryCreateTypes := not failed;
end;

function CodeGenerator.TryCreateMethod(
    context : ^CompilerContext;
    typeDef : ^TypeDefinition;
    method : ^MethodDeclaration;
    methodInfoRef : ^^MethodInfo) : boolean;
var
    methodInfo : ^MethodInfo = nil;
    methodReturnType : ^TypeReference = nil;
    resolvedMethodReturnType : ^TypeDefinition = nil;
    paramDef : ^TypeDefinition = nil;
    paramInfo : ^ParameterInfo = nil;
    methodParams : ^LinkedListOfParameterDeclaration = nil;
    currentParam : ^ParameterDeclaration = nil;
    paramNames : ^LinkedListOfString = nil;
    paramEnum : LinkedListEnumeratorOfParameterDeclaration;
    paramNameEnum : LinkedListEnumeratorOfString;
    success : boolean;
begin
    methodInfo := new MethodInfo(typeDef);
    success := methodInfo <> nil;
    if success then
    begin
        methodInfo^.SetName(method^.GetMethodName());
        methodInfo^.SetIsStatic(method^.GetIsStatic());
        methodInfo^.SetIsVirtual(
            method^.GetIsVirtual() or 
            method^.GetIsAbstract() or
            typeDef^.GetIsInterface());
        methodInfo^.SetIsAbstract(
            method^.GetIsAbstract() or
            typeDef^.GetIsInterface());
        methodReturnType := method^.GetReturnType();
        if methodReturnType <> nil then
        begin
            success := TryResolveTypeReference(
                context,
                methodReturnType,
                @resolvedMethodReturnType);
            if success then
            begin
                methodInfo^.SetReturnType(resolvedMethodReturnType);
            end;
        end;

        methodParams := method^.GetParameters();
        paramEnum := methodParams^.GetEnumerator();
        while success and paramEnum.MoveNext() do
        begin
            currentParam := paramEnum.GetCurrent();
            success := TryResolveTypeReference(
                context,
                currentParam^.GetParameterType(),
                @paramDef);
            if success then 
            begin
                paramNames := currentParam^.GetParameterNames();
                paramNameEnum := paramNames^.GetEnumerator();
                while success and paramNameEnum.MoveNext() do
                begin
                    paramInfo := new ParameterInfo(
                        paramNameEnum.GetCurrent(),
                        paramDef);
                    success := paramInfo <> nil;
                    if success then
                    begin
                        success := methodInfo^.AddParameter(paramInfo);
                        if not success then
                            delete paramInfo;
                    end;
                end;
            end;
        end;
    end;
    
    if not success and (methodInfo <> nil) then
    begin
        delete methodInfo;
        methodInfo := nil;
    end;

    methodInfoRef^ := methodInfo;
    TryCreateMethod := success;
end;

function CodeGenerator.CreateModule(
    context : ^CompilerContext;
    programUnit : ^ProgramUnit) : ^Module;
var
    module : ^Module = nil;
    methodDefs : ^LinkedListOfMethodDefinition;
    methodDef : ^MethodDefinition;
    methodDefEnum : LinkedListEnumeratorOfMethodDefinition; 
    failed : boolean = false;
begin
    module := new Module();
    if module <> nil then
    begin
        methodDefs := programUnit^.GetMethods();
        methodDefEnum := methodDefs^.GetEnumerator();
        while methodDefEnum.MoveNext() do 
        begin
            methodDef := methodDefEnum.GetCurrent();                
            if not TryImplementMethod(
                context,
                module,
                methodDef) then
                failed := true;
        end;
    end;

    if failed then
    begin
        delete module;
        module := nil;
    end;

    CreateModule := module;
end;

function CodeGenerator.TryImplementMethod(
    context : ^CompilerContext;
    module : ^Module;
    methodDef : ^MethodDefinition) : boolean; 
var
    methodInfo : ^MethodInfo = nil;
    methodImpl : ^MethodImpl = nil;
    parameters : LinkedListOfTypeDefinition;
    sourceParameters : ^LinkedListOfParameterDeclaration;
    paramEnum : LinkedListEnumeratorOfParameterDeclaration;
    paramNames : ^LinkedListOfString;
    paramNameEnum : LinkedListEnumeratorOfString;
    paramDecl : ^ParameterDeclaration;
    paramType : ^TypeDefinition;
    methodOwnerType : ^TypeDefinition = nil;
    statementVisitor : StatementVisitor;
    success : boolean = true;
begin
    sourceParameters := methodDef^.GetParameters();
    paramEnum := sourceParameters^.GetEnumerator();
    while success and paramEnum.MoveNext() do 
    begin
        paramDecl := paramEnum.GetCurrent();
        success := TryResolveTypeReference(
            context,
            paramDecl^.GetParameterType(),
            @paramType);
        if success then
        begin
            paramNames := paramDecl^.GetParameterNames();
            paramNameEnum := paramNames^.GetEnumerator();
            while success and paramNameEnum.MoveNext() do
            begin
                success := parameters.Add(paramType);
            end;
        end;
    end;

    if success then
        success := context^.TryFindMethodAndType(
            methodDef^.GetMethodNameReference(),
            @parameters,
            @methodOwnerType,
            @methodInfo);
    if not success then
    begin
        {TODO: Can't find method error}
    end;

    if success then
    begin
        methodImpl := new MethodImpl(module, methodInfo);
        success := methodImpl <> nil;
    end;

    if success then
        success := context^.BeginScope(methodInfo, methodImpl^.GetScope());

    if success then
        success := DefineLocalVariables(context, methodImpl, methodDef);

    statementVisitor := StatementVisitor(context, this, methodImpl, _log); 
    if success then
        statementVisitor.Visit(methodDef^.GetBody());

    if success then
        success := module^.AddMethodImpl(methodImpl);

    if not success and (methodImpl <> nil) then
    begin
        delete methodImpl;
    end;

    TryImplementMethod := success;
end;

function CodeGenerator.DefineLocalVariables(
    context : ^CompilerContext;
    methodImpl : ^MethodImpl; 
    methodDef : ^MethodDefinition) : boolean;
var
    localVars : ^VarBlock = nil;
    varDecl : ^VariableDeclaration = nil;
    varTypeRef : ^TypeReference = nil;
    varType : ^TypeDefinition = nil;
    scope : ^Scope = methodImpl^.GetScope();
    localVarList : ^LinkedListOfVariableDeclaration;
    localVarEnum : LinkedListEnumeratorOfVariableDeclaration;
    varNameList : ^LinkedListOfString;
    varNameEnum : LinkedListEnumeratorOfString;
    success : boolean = true;
begin
    localVars := methodDef^.GetLocalVariables();
    if localVars <> nil then
    begin
        localVarList := localVars^.GetVariables();
        localVarEnum := localVarList^.GetEnumerator();
        while success and localVarEnum.MoveNext() do
        begin
            varDecl := localVarEnum.GetCurrent();
            success := TryResolveTypeReference(
                context,
                varDecl^.GetVariableType(),
                @varType);
            if success then
            begin
                varNameList := varDecl^.GetVariableNames();
                varNameEnum := varNameList^.GetEnumerator();
                while success and varNameEnum.MoveNext() do
                begin
                    success := scope^.DefineLocalVariable(
                        varNameEnum.GetCurrent(),
                        varType);
                end;
            end;
        end;
    end;
    DefineLocalVariables := success;
end;

function CodeGenerator.TryResolveTypeReference(
    context : ^CompilerContext;
    typeRef : ^TypeReference;
    typeDefRef : ^^TypeDefinition) : boolean; 
var
    visitor : TypeResolverVisitor;
begin
    visitor := TypeResolverVisitor(
        context,
        this,
        _log);
    typeRef^.Accept(@visitor);
    typeDefRef^ := visitor.GetResult();
    TryResolveTypeReference := typeDefRef^ <> nil;
end;

